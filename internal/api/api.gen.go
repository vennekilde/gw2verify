// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gin-gonic/gin"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AccessType.
const (
	HOMEWORLD   AccessType = "HOME_WORLD"
	LINKEDWORLD AccessType = "LINKED_WORLD"
)

// Defines values for Status.
const (
	ACCESSDENIEDACCOUNTNOTLINKED      Status = "ACCESS_DENIED_ACCOUNT_NOT_LINKED"
	ACCESSDENIEDBANNED                Status = "ACCESS_DENIED_BANNED"
	ACCESSDENIEDEXPIRED               Status = "ACCESS_DENIED_EXPIRED"
	ACCESSDENIEDINVALIDWORLD          Status = "ACCESS_DENIED_INVALID_WORLD"
	ACCESSDENIEDREQUIREMENTNOTMET     Status = "ACCESS_DENIED_REQUIREMENT_NOT_MET"
	ACCESSDENIEDUNKNOWN               Status = "ACCESS_DENIED_UNKNOWN"
	ACCESSGRANTEDHOMEWORLD            Status = "ACCESS_GRANTED_HOME_WORLD"
	ACCESSGRANTEDHOMEWORLDTEMPORARY   Status = "ACCESS_GRANTED_HOME_WORLD_TEMPORARY"
	ACCESSGRANTEDLINKEDWORLD          Status = "ACCESS_GRANTED_LINKED_WORLD"
	ACCESSGRANTEDLINKEDWORLDTEMPORARY Status = "ACCESS_GRANTED_LINKED_WORLD_TEMPORARY"
)

// APIKeyData defines model for APIKeyData.
type APIKeyData struct {
	// Apikey The api to set for the user
	Apikey string `json:"apikey"`

	// Primary Set if the user should be the primary user of that particular service. There can only be one per service per account. Setting a new primary user will override the old one
	Primary bool `json:"primary"`
}

// APIKeyName defines model for APIKeyName.
type APIKeyName struct {
	// Name The apikey name the user has to name their apikey if apikey name is enforced
	Name string `json:"name"`
}

// AccessType defines model for AccessType.
type AccessType string

// Account defines model for Account.
type Account struct {
	Access       *[]string  `json:"access,omitempty"`
	Age          int        `json:"age"`
	Commander    bool       `json:"commander"`
	Created      time.Time  `json:"created"`
	DailyAp      *int       `json:"daily_ap,omitempty"`
	DbCreated    *time.Time `json:"db_created,omitempty"`
	DbUpdated    *time.Time `json:"db_updated,omitempty"`
	FractalLevel *int       `json:"fractal_level,omitempty"`
	GuildLeader  *[]string  `json:"guild_leader,omitempty"`
	Guilds       *[]string  `json:"guilds,omitempty"`
	Id           string     `json:"id"`
	MonthlyAp    *int       `json:"monthly_ap,omitempty"`
	Name         string     `json:"name"`
	UserID       *int       `json:"user_id,omitempty"`
	World        int        `json:"world"`
	WvwRank      *int       `json:"wvw_rank,omitempty"`
}

// BanData defines model for BanData.
type BanData struct {
	Reason string    `json:"reason"`
	Until  time.Time `json:"until"`
}

// ChannelMetadata defines model for ChannelMetadata.
type ChannelMetadata struct {
	Name  string                `json:"name"`
	Users []ChannelUserMetadata `json:"users"`
}

// ChannelUserMetadata defines model for ChannelUserMetadata.
type ChannelUserMetadata struct {
	Deafened  bool   `json:"deafened"`
	Id        string `json:"id"`
	Muted     bool   `json:"muted"`
	Name      string `json:"name"`
	Streaming bool   `json:"streaming"`
}

// Configuration defines model for Configuration.
type Configuration struct {
	ExpirationTime                int `json:"expiration_time"`
	TemporaryAccessExpirationTime int `json:"temporary_access_expiration_time"`

	// WorldLinks List of worlds links
	WorldLinks map[string]WorldLinks `json:"world_links"`
}

// Error defines model for Error.
type Error struct {
	Error            string `json:"error"`
	SafeDisplayError string `json:"safe-display-error"`
}

// Property defines model for Property.
type Property struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// ServiceLink defines model for ServiceLink.
type ServiceLink struct {
	DisplayName *string `json:"display_name,omitempty"`
	Primary     bool    `json:"primary"`

	// ServiceId ID of the service the user id belongs to
	ServiceID     int    `json:"service_id"`
	ServiceUserID string `json:"service_user_id"`
}

// Status defines model for Status.
type Status string

// TemporaryData defines model for TemporaryData.
type TemporaryData struct {
	AccessType *AccessType `json:"access_type,omitempty"`

	// DisplayName Display name of the user of the service. Will be stored as the latest used diplay name by that user
	DisplayName *string `json:"display_name,omitempty"`
	World       *int    `json:"world,omitempty"`
}

// VerificationStatus defines model for VerificationStatus.
type VerificationStatus struct {
	Account     *Account  `json:"account,omitempty"`
	Attributes  *[]string `json:"attributes,omitempty"`
	Ban         *BanData  `json:"ban,omitempty"`
	Description *string   `json:"description,omitempty"`

	// Expires if set, the access is only temporary and will expire at the given date
	Expires     *time.Time   `json:"expires,omitempty"`
	IsPrimary   *bool        `json:"is_primary,omitempty"`
	ServiceLink *ServiceLink `json:"service_link,omitempty"`
	Status      Status       `json:"status"`
	World       *int         `json:"world,omitempty"`
}

// VerificationStatusOverview defines model for VerificationStatusOverview.
type VerificationStatusOverview struct {
	Account     *Account  `json:"account,omitempty"`
	Attributes  *[]string `json:"attributes,omitempty"`
	Ban         *BanData  `json:"ban,omitempty"`
	Description *string   `json:"description,omitempty"`

	// Expires if set, the access is only temporary and will expire at the given date
	Expires      *time.Time            `json:"expires,omitempty"`
	IsPrimary    *bool                 `json:"is_primary,omitempty"`
	ServiceLink  *ServiceLink          `json:"service_link,omitempty"`
	ServiceLinks *[]ServiceLink        `json:"service_links,omitempty"`
	Status       Status                `json:"status"`
	Statuses     *[]VerificationStatus `json:"statuses,omitempty"`
	World        *int                  `json:"world,omitempty"`
}

// WorldLinks defines model for WorldLinks.
type WorldLinks = []int

// TraitSecuredAuthentication defines model for trait_secured_authentication.
type TraitSecuredAuthentication = string

// TraitWorldOrientedWorld defines model for trait_world_oriented_world.
type TraitWorldOrientedWorld = int

// TraitErrorResp defines model for trait_error_resp.
type TraitErrorResp = Error

// POSTV1ChannelsServiceIdChannelStatisticsParams defines parameters for POSTV1ChannelsServiceIdChannelStatistics.
type POSTV1ChannelsServiceIdChannelStatisticsParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// GETV1ConfigurationParams defines parameters for GETV1Configuration.
type GETV1ConfigurationParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// GETV1UpdatesServiceIdSubscribeParams defines parameters for GETV1UpdatesServiceIdSubscribe.
type GETV1UpdatesServiceIdSubscribeParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// PUTV1UsersServiceIdServiceUserIdApikeyParams defines parameters for PUTV1UsersServiceIdServiceUserIdApikey.
type PUTV1UsersServiceIdServiceUserIdApikeyParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`

	// SkipRequirements Skip the variuse apikey requirements that might be in place
	SkipRequirements *bool `form:"skip-requirements,omitempty" json:"skip-requirements,omitempty"`
}

// GETV1UsersServiceIdServiceUserIdApikeyNameParams defines parameters for GETV1UsersServiceIdServiceUserIdApikeyName.
type GETV1UsersServiceIdServiceUserIdApikeyNameParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// PUTV1UsersServiceIdServiceUserIdPropertiesParams defines parameters for PUTV1UsersServiceIdServiceUserIdProperties.
type PUTV1UsersServiceIdServiceUserIdPropertiesParams struct {
	// Name Property name
	Name string `form:"name" json:"name"`

	// Value Property value
	Value string `form:"value" json:"value"`
}

// GETV1UsersServiceIdServiceUserIdPropertiesPropertyParams defines parameters for GETV1UsersServiceIdServiceUserIdPropertiesProperty.
type GETV1UsersServiceIdServiceUserIdPropertiesPropertyParams struct {
	// Name Property name
	Name string `form:"name" json:"name"`
}

// POSTV1UsersServiceIdServiceUserIdVerificationRefreshParams defines parameters for POSTV1UsersServiceIdServiceUserIdVerificationRefresh.
type POSTV1UsersServiceIdServiceUserIdVerificationRefreshParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// GETV1UsersServiceIdServiceUserIdVerificationStatusParams defines parameters for GETV1UsersServiceIdServiceUserIdVerificationStatus.
type GETV1UsersServiceIdServiceUserIdVerificationStatusParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`

	// DisplayName Display name of the user of the service. Will be stored as the latest used diplay name by that user
	DisplayName *string `form:"display_name,omitempty" json:"display_name,omitempty"`
}

// PUTV1UsersServiceIdServiceUserIdVerificationTemporaryParams defines parameters for PUTV1UsersServiceIdServiceUserIdVerificationTemporary.
type PUTV1UsersServiceIdServiceUserIdVerificationTemporaryParams struct {
	World *TraitWorldOrientedWorld `form:"world,omitempty" json:"world,omitempty"`
}

// POSTV1ChannelsServiceIdChannelStatisticsJSONRequestBody defines body for POSTV1ChannelsServiceIdChannelStatistics for application/json ContentType.
type POSTV1ChannelsServiceIdChannelStatisticsJSONRequestBody = ChannelMetadata

// PUTV1UsersServiceIdServiceUserIdApikeyJSONRequestBody defines body for PUTV1UsersServiceIdServiceUserIdApikey for application/json ContentType.
type PUTV1UsersServiceIdServiceUserIdApikeyJSONRequestBody = APIKeyData

// PUTV1UsersServiceIdServiceUserIdBanJSONRequestBody defines body for PUTV1UsersServiceIdServiceUserIdBan for application/json ContentType.
type PUTV1UsersServiceIdServiceUserIdBanJSONRequestBody = BanData

// PUTV1UsersServiceIdServiceUserIdVerificationTemporaryJSONRequestBody defines body for PUTV1UsersServiceIdServiceUserIdVerificationTemporary for application/json ContentType.
type PUTV1UsersServiceIdServiceUserIdVerificationTemporaryJSONRequestBody = TemporaryData

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /v1/channels/{service_id}/{channel}/statistics)
	POSTV1ChannelsServiceIdChannelStatistics(c *gin.Context, serviceId int, channel string, params POSTV1ChannelsServiceIdChannelStatisticsParams)

	// (GET /v1/configuration)
	GETV1Configuration(c *gin.Context, params GETV1ConfigurationParams)

	// (GET /v1/updates/{service_id}/subscribe)
	GETV1UpdatesServiceIdSubscribe(c *gin.Context, serviceId int, params GETV1UpdatesServiceIdSubscribeParams)

	// (PUT /v1/users/{service_id}/{service_user_id}/apikey)
	PUTV1UsersServiceIdServiceUserIdApikey(c *gin.Context, serviceId int, serviceUserId string, params PUTV1UsersServiceIdServiceUserIdApikeyParams)

	// (GET /v1/users/{service_id}/{service_user_id}/apikey/name)
	GETV1UsersServiceIdServiceUserIdApikeyName(c *gin.Context, serviceId int, serviceUserId string, params GETV1UsersServiceIdServiceUserIdApikeyNameParams)

	// (PUT /v1/users/{service_id}/{service_user_id}/ban)
	PUTV1UsersServiceIdServiceUserIdBan(c *gin.Context, serviceId int, serviceUserId string)

	// (GET /v1/users/{service_id}/{service_user_id}/properties)
	GETV1UsersServiceIdServiceUserIdProperties(c *gin.Context, serviceId int, serviceUserId string)

	// (PUT /v1/users/{service_id}/{service_user_id}/properties)
	PUTV1UsersServiceIdServiceUserIdProperties(c *gin.Context, serviceId int, serviceUserId string, params PUTV1UsersServiceIdServiceUserIdPropertiesParams)

	// (GET /v1/users/{service_id}/{service_user_id}/properties/{property})
	GETV1UsersServiceIdServiceUserIdPropertiesProperty(c *gin.Context, serviceId int, serviceUserId string, property string, params GETV1UsersServiceIdServiceUserIdPropertiesPropertyParams)

	// (POST /v1/users/{service_id}/{service_user_id}/verification/refresh)
	POSTV1UsersServiceIdServiceUserIdVerificationRefresh(c *gin.Context, serviceId int, serviceUserId string, params POSTV1UsersServiceIdServiceUserIdVerificationRefreshParams)

	// (GET /v1/users/{service_id}/{service_user_id}/verification/status)
	GETV1UsersServiceIdServiceUserIdVerificationStatus(c *gin.Context, serviceId int, serviceUserId string, params GETV1UsersServiceIdServiceUserIdVerificationStatusParams)

	// (PUT /v1/users/{service_id}/{service_user_id}/verification/temporary)
	PUTV1UsersServiceIdServiceUserIdVerificationTemporary(c *gin.Context, serviceId int, serviceUserId string, params PUTV1UsersServiceIdServiceUserIdVerificationTemporaryParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// POSTV1ChannelsServiceIdChannelStatistics operation middleware
func (siw *ServerInterfaceWrapper) POSTV1ChannelsServiceIdChannelStatistics(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "channel" -------------
	var channel string

	err = runtime.BindStyledParameter("simple", false, "channel", c.Param("channel"), &channel)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter channel: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params POSTV1ChannelsServiceIdChannelStatisticsParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.POSTV1ChannelsServiceIdChannelStatistics(c, serviceId, channel, params)
}

// GETV1Configuration operation middleware
func (siw *ServerInterfaceWrapper) GETV1Configuration(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GETV1ConfigurationParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1Configuration(c, params)
}

// GETV1UpdatesServiceIdSubscribe operation middleware
func (siw *ServerInterfaceWrapper) GETV1UpdatesServiceIdSubscribe(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GETV1UpdatesServiceIdSubscribeParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1UpdatesServiceIdSubscribe(c, serviceId, params)
}

// PUTV1UsersServiceIdServiceUserIdApikey operation middleware
func (siw *ServerInterfaceWrapper) PUTV1UsersServiceIdServiceUserIdApikey(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PUTV1UsersServiceIdServiceUserIdApikeyParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "skip-requirements" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip-requirements", c.Request.URL.Query(), &params.SkipRequirements)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter skip-requirements: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PUTV1UsersServiceIdServiceUserIdApikey(c, serviceId, serviceUserId, params)
}

// GETV1UsersServiceIdServiceUserIdApikeyName operation middleware
func (siw *ServerInterfaceWrapper) GETV1UsersServiceIdServiceUserIdApikeyName(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GETV1UsersServiceIdServiceUserIdApikeyNameParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1UsersServiceIdServiceUserIdApikeyName(c, serviceId, serviceUserId, params)
}

// PUTV1UsersServiceIdServiceUserIdBan operation middleware
func (siw *ServerInterfaceWrapper) PUTV1UsersServiceIdServiceUserIdBan(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PUTV1UsersServiceIdServiceUserIdBan(c, serviceId, serviceUserId)
}

// GETV1UsersServiceIdServiceUserIdProperties operation middleware
func (siw *ServerInterfaceWrapper) GETV1UsersServiceIdServiceUserIdProperties(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1UsersServiceIdServiceUserIdProperties(c, serviceId, serviceUserId)
}

// PUTV1UsersServiceIdServiceUserIdProperties operation middleware
func (siw *ServerInterfaceWrapper) PUTV1UsersServiceIdServiceUserIdProperties(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PUTV1UsersServiceIdServiceUserIdPropertiesParams

	// ------------- Required query parameter "name" -------------

	if paramValue := c.Query("name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "value" -------------

	if paramValue := c.Query("value"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument value is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "value", c.Request.URL.Query(), &params.Value)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter value: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PUTV1UsersServiceIdServiceUserIdProperties(c, serviceId, serviceUserId, params)
}

// GETV1UsersServiceIdServiceUserIdPropertiesProperty operation middleware
func (siw *ServerInterfaceWrapper) GETV1UsersServiceIdServiceUserIdPropertiesProperty(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "property" -------------
	var property string

	err = runtime.BindStyledParameter("simple", false, "property", c.Param("property"), &property)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter property: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GETV1UsersServiceIdServiceUserIdPropertiesPropertyParams

	// ------------- Required query parameter "name" -------------

	if paramValue := c.Query("name"); paramValue != "" {

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Query argument name is required, but not found"), http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "name", c.Request.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter name: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1UsersServiceIdServiceUserIdPropertiesProperty(c, serviceId, serviceUserId, property, params)
}

// POSTV1UsersServiceIdServiceUserIdVerificationRefresh operation middleware
func (siw *ServerInterfaceWrapper) POSTV1UsersServiceIdServiceUserIdVerificationRefresh(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params POSTV1UsersServiceIdServiceUserIdVerificationRefreshParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.POSTV1UsersServiceIdServiceUserIdVerificationRefresh(c, serviceId, serviceUserId, params)
}

// GETV1UsersServiceIdServiceUserIdVerificationStatus operation middleware
func (siw *ServerInterfaceWrapper) GETV1UsersServiceIdServiceUserIdVerificationStatus(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GETV1UsersServiceIdServiceUserIdVerificationStatusParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "display_name" -------------

	err = runtime.BindQueryParameter("form", true, false, "display_name", c.Request.URL.Query(), &params.DisplayName)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter display_name: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GETV1UsersServiceIdServiceUserIdVerificationStatus(c, serviceId, serviceUserId, params)
}

// PUTV1UsersServiceIdServiceUserIdVerificationTemporary operation middleware
func (siw *ServerInterfaceWrapper) PUTV1UsersServiceIdServiceUserIdVerificationTemporary(c *gin.Context) {

	var err error

	// ------------- Path parameter "service_id" -------------
	var serviceId int

	err = runtime.BindStyledParameter("simple", false, "service_id", c.Param("service_id"), &serviceId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_id: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Path parameter "service_user_id" -------------
	var serviceUserId string

	err = runtime.BindStyledParameter("simple", false, "service_user_id", c.Param("service_user_id"), &serviceUserId)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter service_user_id: %s", err), http.StatusBadRequest)
		return
	}

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params PUTV1UsersServiceIdServiceUserIdVerificationTemporaryParams

	// ------------- Optional query parameter "world" -------------

	err = runtime.BindQueryParameter("form", true, false, "world", c.Request.URL.Query(), &params.World)
	if err != nil {
		siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter world: %s", err), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.PUTV1UsersServiceIdServiceUserIdVerificationTemporary(c, serviceId, serviceUserId, params)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/v1/channels/:service_id/:channel/statistics", wrapper.POSTV1ChannelsServiceIdChannelStatistics)
	router.GET(options.BaseURL+"/v1/configuration", wrapper.GETV1Configuration)
	router.GET(options.BaseURL+"/v1/updates/:service_id/subscribe", wrapper.GETV1UpdatesServiceIdSubscribe)
	router.PUT(options.BaseURL+"/v1/users/:service_id/:service_user_id/apikey", wrapper.PUTV1UsersServiceIdServiceUserIdApikey)
	router.GET(options.BaseURL+"/v1/users/:service_id/:service_user_id/apikey/name", wrapper.GETV1UsersServiceIdServiceUserIdApikeyName)
	router.PUT(options.BaseURL+"/v1/users/:service_id/:service_user_id/ban", wrapper.PUTV1UsersServiceIdServiceUserIdBan)
	router.GET(options.BaseURL+"/v1/users/:service_id/:service_user_id/properties", wrapper.GETV1UsersServiceIdServiceUserIdProperties)
	router.PUT(options.BaseURL+"/v1/users/:service_id/:service_user_id/properties", wrapper.PUTV1UsersServiceIdServiceUserIdProperties)
	router.GET(options.BaseURL+"/v1/users/:service_id/:service_user_id/properties/:property", wrapper.GETV1UsersServiceIdServiceUserIdPropertiesProperty)
	router.POST(options.BaseURL+"/v1/users/:service_id/:service_user_id/verification/refresh", wrapper.POSTV1UsersServiceIdServiceUserIdVerificationRefresh)
	router.GET(options.BaseURL+"/v1/users/:service_id/:service_user_id/verification/status", wrapper.GETV1UsersServiceIdServiceUserIdVerificationStatus)
	router.PUT(options.BaseURL+"/v1/users/:service_id/:service_user_id/verification/temporary", wrapper.PUTV1UsersServiceIdServiceUserIdVerificationTemporary)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
